/*
适用动态规划算法的条件：
1.存在最优子结构：一个问题的最优解包含其子问题最优解，则称为为具有最优子结构
2.存在重叠的子问题：即子问题中存在相同的子子问题。
动态规划算法就是在求解子问题时，设置一张表来存储子问题的解，在计算某个子问题时，先从
缓存表中查找是否已经存在该子问题的解(是否已经求解过该子问题),如果存在，则直接得到结果，
否则计算该子问题的解，并存入缓存表中。因为存在着重叠的子问题，所以避免了重复求解相同子问题，
从而大大提高了求解原问题的效率。而分治或者暴力遍历的解法，由于重复求解相同的子问题，往往效率是很低的。
 */
/*
	01背包问题：
	有N件(每种类型只有一件)物品，每件物品对应的重量为wi,价值为vi,和一个容量W的背包，
	求解将那些物品放入背包中(总的重量不能超过背包的容量)，使得总的价值最大
	如N件物品为：
	[[15,15],[7,2],[8,14]]
	背包的容量为15，
	则把[7,2],[8,14]装入背包可得到最大价值为16

	解：
	背包问题是一个动态规划问题。所以使用动态规划算法来解决。
	假设dp[i][w]为将前i个物品放入背包容量为w的背包中所得的最大价值，则
	对于第i件物品，存在两种选择，放入背包或者不放入。所以状态转移方程为：
	dp[i][w] = max(dp[i-1][w], dp[i-1][w-wi] + vi)
	其中wi为第i件物品的重量，vi为其价值
 */

/*
	@param costs array 每件物品重量和价值
	@param n number 背包的容量
	时间复杂度：n * costs.length
	空间复杂度：n * costs.length
 */
function knapsack_01 (costs, n) {
	const dp = [];
	for (let i = 0 ; i <= costs.length; i++) {
		dp[i] = [0];
	}
	for (let j = 0 ; j <= n ; j++) {
		dp[0][j] = 0;
	}

	for (let i = 1; i <= costs.length; i++) {
		const cost = costs[i-1];
		for (let j = 1; j <= n; j++) {
			// 只有在背包还能放得下第i件物品时, 才进行选择
			if (cost[0] <= j) {
				dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j - cost[0]] + cost[1]);
			} else {
				dp[i][j] = dp[i-1][j];
			}
		}
	}

	return dp[costs.length][n];
}

/* 
	优化空间复杂度
	 从上面的动态规划过程可以看出，空间复杂度存在优化的空间，
	 因为计算dp[i][j]时，只用到了dp[i-1]行的数据，所以可以只是用一维数组d来存储子问题的解。
	 因为要使用一维数组存储子问题的解，所以只能存储的是d[i-1]的子问题的解，即d[0...W]存储
	 的是dp[i-1][w]的解，那么要求解dp[i][w](即d[i])时，怎么样得到dp[i-1][j]和dp[i-1][w-wi]?
	 要得到dp[i-1][j]和dp[i-1][w-wi]，只能是从d[j]和d[w-wi]中得到，但是如果按照上面的动态规划
	 遍历的次序，是不能保证d[j]和d[w-wi]为dp[i-1][j]和dp[i-1][w-wi]，因为d[w-wi]可能是d[i][w-wi]，
	 所以可以在第二层遍历的时候，j不是从1到n, 而是从n到1，这样就能保证d[j]之前的项，保存的都是
	 dp[i-1][0..j]的子问题的解。
	 所以状态转移方程为：
	 d[j] = max(d[j], d[j-wi]+vi)
	 其中第二个d[j]即为dp[i-1][j], d[j-wi]为d[i-1][j-wi]

	时间复杂度：n * costs.length
	空间复杂度：n 
*/ 

function knapsack_01_2 (costs, n) {
	const dp = [];
	for (let i = 0 ; i <= n; i++) {
		dp[i] = 0;
	}

	for (let i = 1; i <= costs.length; i++) {
		const cost = costs[i-1];
		for (let j = n; j >= 0; j--) {
			// 只有在背包还能放得下第i件物品时, 才进行选择
			if (cost[0] <= j) {
				dp[j] = Math.max(dp[j], dp[j - cost[0]] + cost[1]);
			}
		}
	}

	return dp[n];
}

console.log(knapsack_01([[7,15],[7,2],[8,12]], 15))
console.log(knapsack_01_2([[7,15],[7,2],[8,12]], 15))
