// 二分分治法求两个有序数组的中位数或者top k, 时间复杂度： log(n + m)

// 算法思路：
/*
	中值和top k 问题
	知识点：
	1。对于单数组来说，如果是奇数组，割在某个数上时，可以一分为二，这样不管是偶数组或者单数组，都能统一运算，
		如：[2,3,5,7] -> (3+5) / 2 = 4. [2,3,4,5,6] -> (4+4) / 2 = 4。
	2。 对于单数组，要找到第k个元素，直接割到第k个位置，即可获得top k.

	3。双数组：设ci为第i个数组的割位置。li为第i个数组割后的左元素，r1为第i个数组割后的右元素，则可推理得：
		1. li < ri。显然成立的，因为数组的有序的。
		2.如果让 l1 < r2 && l2 < r1,则可推出左半边全部小于右半边，那么如果左半边的元素的个数相加刚好等于k,那么
		第k个元素就是max(l1, l2)。
		3.如果l1 > r2,说明数组1的左半边的元素太大，那么要把数组1的分割处变小，数组2的分割处变大，即c1减少,
			c2增大。同理l2 > r1时，c1增大，c2减小。直到满足条件2，则便可求得top k。要求中值时，只需要k为中值
			的位置即可。

		例如：对于[1,4,6,9]和[2,3,5]， k = 3。设c1为2，则c2 = k - c1 = 1,即[1,4,/6,9],[2,/3,5]。因为l1 > r2,
		则需要c1变小，c2变大 -> c1 = 1, c2 = k - c1 = 2, 这时[1,/4,6,9],[2,3,/5],满足l1 < r2 && l2 < r1,同时
		数组1和数组2左半边个数等于k.所以top k = max(l1, l2) = max(1,3) = 3.

	4。双数组的奇偶问题：
		单数组：
		怎么样才能确定中位数的分割处呢，对于偶数组来说，它的分割处是两数之间，能不能把数组恒为奇数组呢？
		这样中位数的分割处就会在中间的位置的元素上，然后k为该位置即可求出中位数。让数组恒为奇数组的方法就是
		让数组的长度变为2n + 1。例如在数组中虚拟加入#,这样数组就恒为奇数组。如：
		[1,4,7,9] -> [#,1,#,4,#,7,#,9,#] lenght - > 9, [2,3,5] -> [#,2,#,3,#,5,#] length -> 7。但实际编码的时候，不会实际在数组
		中添加#，而是通过转化达到同样的效果。
		对于原偶数组[1,4,7,9],k = 3时, 原分割位置c1 = 2,模拟添加#后的分割位置为 (9 + 1) / 2 = 5, 转化 5 / 2 >> 0 = 2,
		和原来的分割位置一样。对于原奇数组[2,3,5], 原分割位置 c2 = k - c1 = 1, 模拟添加#后，分割的位置为：
		c2 = 7 - 5 = 2 转化 2 / 2 >> 0 = 1,可以看出模拟经过转化后的分割处和原来的并没有变化。
		所以li和ri的计算公式为：
		li = (ci - 1) / 2 >> 0
		ri = (ci + 1) / 2 >> 0
		
		越界问题：有个数组完全小于或大于中值，则：
			c1 = 0 -> 数组1整体都比中值大，l1 > r2, 则中值在数组2中
			c2 = 0 -> 数组1


		双数组：
			把这两个数组看成是各自模拟数组的组合的单数组，则该单数组有2n+1+2m+1个元素(偶数).则中位数割处为：(2n+1+2m+1) / 2 ->
			m+n+1.则我们只需要找到m+n+1位置和m+n+1+1处的元素，即可求出中位数。
			至于在两个数组中找top k 的方案，也就是第4点的方案。
 */

// 分治法

var a = [1,4,7,9]
var b = [2]

// 中位数和top k 的问题
function findMedian(a, b, k) {
	var m = a.length, n = b.length;
	// 二分分治求值时，以长度比较短的数组作为基准分支，效率高一些
	if (n < m) {
		var temp = a
		a = b
		b = temp
		m = a.length
		n = b.length
	}
	// j = m *2 + 1,保证了数组的长度为奇数
	var l1,l2,r1,r2,c1,c2,i = 0,j = m * 2; // j = m * 2 + 1 - 1

	// 进行二分分治查找top k
	while(i <= j) {
		c1 = (i + j) / 2 >> 0 // 对a数组进行二分
		// m + n + 1 - 1为合并后的数组的中位数
		c2 = k ? 2 * k - c1 : ((m + n) - c1) >> 0

		// 如果c1 === 0 那么l1赋值极小值，这样左边的最大值便是l2
		l1 = c1 === 0 ? Number.MIN_VALUE : a[(c1 - 1) / 2 >> 0]
		r1 = c1 === 2 * m ? Number.MAX_VALUE : a[c1 / 2 >> 0] 

		l2 = c2 === 0 ? Number.MIN_VALUE : b[(c2 - 1) / 2 >> 0]
		r2 = c2 === 2 * n ? Number.MAX_VALUE : b[c2 / 2 >> 0] 

		if (l1 > r2) {
			// c1要变小，c2要变大
			j = c1 - 1
		} else if (l2 > r1) {
			// c1要变大，c2要变小
			i = c1 + 1
		} else {
			// 说明 l1 <= r2, l2 <= r1
			break
		}
	}
	// Math.max(l1, l2)即为top k, Math.min(r1, r2)则为top (k+1),
	// 则中位数为 (top k + top (k+1)) / 2
	return k ? Math.max(l1, l2) : (Math.max(l1, l2) + Math.min(r1, r2)) / 2
}

// console.log(findMedian(b, a, 4))

// 根据第三点的算法,该算法不用统一处理合并后的数组的奇偶性，而是对于奇偶性进行不同的处理.
// 即如果合并后的数组为即数组，那么中位数即为top k, 否者为(top k + top (k +1)) / 2
function findMedian2(A, B) {
	
	let m = A.length,
      n = B.length;
      
  // 以长度较小的数组作为基数组
  if (m > n) {
    [A, B] = [B, A]
    let temp = m;
    m = n;
    n = temp;
  }

  // 为运算 >> 1  -> 除以2取整
  let iMin = 0, iMax = m, half = (m + n + 1) >> 1, c1, c2;

  while (iMin <= iMax) {
    c1 = (iMin + iMax) >> 1;
    c2 = half - c1;

    // r1 = A[c1] = A[c1 + 1 - 1], 数组的下标要减1
    if (c1 < iMax && B[c2 - 1] > A[c1]) {
    	// l2 > r1
    	// 数组1要增大
      iMin = iMin + 1
    } else if (c1 > iMin && B[c2] < A[c1 - 1]) {
    	// l1 > r2
    	// 数组1要减小
      iMax = iMax - 1
    } else {
    	// c1 > imax || c1 < imin 越界
    	
      let maxLeft = 0;
      if (c1 === 0) {
      	// c1 < imin 越界,说明数组1，都比中位数大，则中位数在数组2中
        maxLeft = B[c2 - 1]
      } else if (c2 === 0) {
      	// c2 < imin 越界,说明数组2，都比中位数大，则中位数在数组1中
        maxLeft = A[c1 - 1]
      } else {
      	// 否者取两个数组左半边中最大的值作为top k
        maxLeft = Math.max(A[c1 - 1], B[c2 - 1])
      }

      // 中位值分割处在数字上，则直接返回maxLeft
      if ((m + n) & 1 !== 0) return maxLeft;

      // 否者中位数在两数之间，求top k + 1,
      let minRight = 0;
      if (c1 === m) {
      	// c1 > imax 越界。说明数组1都比中位数小，则中位数在数组2中
        minRight = B[c2]
      } else if (c2 === n) {
      	// c2 > imax 越界。说明数组2都比中位数小，则中位数在数组1中
        minRight = A[c1]
      } else {
      	// 取两者最小值作为 top k + 1
        minRight = Math.min(A[c1], B[c2])
      }

      // 中位数为 (top k + top (k + 1)) / 2
      return (maxLeft + minRight) / 2
    }
  }
}

console.log(findMedian2([1,3,5,7,8,9,10], [2,4,6,11,12]))
console.log(findMedian2(a, b))

console.log(findMedian(a, b))
console.log(findMedian([1,3,5,7,8,9,10], [2,4,6,11,12]))





