// 二分分治法求两个有序数组的中位数或者top k, 时间复杂度： log(n + m)

// 算法思路：
/*
	中值和top k 问题
	知识点：
	1。对于单数组来说，如果是奇数组，割在某个数上时，可以一分为二，这样不管是偶数组或者单数组，都能统一运算，
		如：[2,3,5,7] -> (3+5) / 2 = 4. [2,3,4,5,6] -> (4+4) / 2 = 4。
	2。 对于单数组，要找到第k个元素，直接割到第k个位置，即可获得top k.

	3。双数组：设ci为第i个数组的割位置。li为第i个数组割后的左元素，r1为第i个数组割后的右元素，则可推理得：
		1. li < ri。显然成立的，因为数组的有序的。
		2.如果让 l1 < r2 && l2 < r1,则可推出左半边全部小于右半边，那么如果左半边的元素的个数相加刚好等于k,那么
		第k个元素就是max(l1, l2)。
		3.如果l1 > r2,说明数组1的左半边的元素太大，那么要把数组1的分割处变小，数组2的分割处变大，即c1减少,
			c2增大。同理l2 > r1时，c1增大，c2减小。直到满足条件2，则便可求得top k。要求中值时，只需要k为中值
			的位置即可。

		例如：对于[1,4,6,9]和[2,3,5]， k = 3。设c1为2，则c2 = k - c1 = 1,即[1,4,/6,9],[2,/3,5]。因为l1 > r2,
		则需要c1变小，c2变大 -> c1 = 1, c2 = k - c1 = 2, 这时[1,/4,6,9],[2,3,/5],满足l1 < r2 && l2 < r1,同时
		数组1和数组2左半边个数等于k.所以top k = max(l1, l2) = max(1,3) = 3.

	4。双数组的奇偶问题：
		单数组：
		怎么样才能确定中位数的分割处呢，对于偶数组来说，它的分割处是两数之间，能不能把数组恒为奇数组呢？
		这样中位数的分割处就会在中间的位置的元素上，然后k为该位置即可求出中位数。让数组恒为奇数组的方法就是
		让数组的长度变为2n + 1。例如在数组中虚拟加入#,这样数组就恒为奇数组。如：
		[1,4,7,9] -> [#,1,#,4,#,7,#,9,#] lenght - > 9, [2,3,5] -> [#,2,#,3,#,5,#] length -> 7。但实际编码的时候，不会实际在数组
		中添加#，而是通过转化达到同样的效果。
		对于原偶数组[1,4,7,9],k = 3时, 原分割位置c1 = 2,模拟添加#后的分割位置为 (9 + 1) / 2 = 5, 转化 5 / 2 >> 0 = 2,
		和原来的分割位置一样。对于原奇数组[2,3,5], 原分割位置 c2 = k - c1 = 1, 模拟添加#后，分割的位置为：
		c2 = 7 - 5 = 2 转化 2 / 2 >> 0 = 1,可以看出模拟经过转化后的分割处和原来的并没有变化。
		所以li和ri的计算公式为：
		li = (ci - 1) / 2 >> 0
		ri = (ci + 1) / 2 >> 0
		
		越界问题：有个数组完全小于或大于中值，则：
			c1 = 0 -> 数组1整体都比中值大，l1 > r2, 则中值在数组2中
			c2 = 0 -> 数组1


		双数组：
			把这两个数组看成是各自模拟数组的组合的单数组，则该单数组有2n+1+2m+1个元素(偶数).则中位数割处为：(2n+1+2m+1) / 2 ->
			m+n+1.则我们只需要找到m+n+1位置和m+n+1+1处的元素，即可求出中位数。
			至于在两个数组中找top k 的方案，也就是第4点的方案。
 */

// 分治法

var a = [1,4,7,9]
var b = [2,3,5]

// 中位数和top k 的问题
function findMedian(a, b, k) {
	var m = a.length, n = b.length;
	// 二分分治求值时，以长度比较短的数组作为基准分支，效率高一些
	if (n < m) {
		var temp = a
		a = b
		b = temp
		m = a.length
		n = b.length
	}
	// j = m *2 + 1,保证了数组的长度为奇数
	var l1,l2,r1,r2,c1,c2,i = 0,j = m * 2; // j = m * 2 + 1 - 1

	// 进行二分分治查找top k
	while(i <= j) {
		c1 = (i + j) / 2 >> 0 // 对a数组进行二分
		// m + n + 1 - 1为合并后的数组的中位数
		c2 = k ? 2 * k - c1 : ((m + n) - c1) >> 0

		l1 = c1 === 0 ? Number.MIN_VALUE : a[(c1 - 1) / 2 >> 0]
		r1 = c1 === 2 * m ? Number.MAX_VALUE : a[c1 / 2 >> 0] 

		l2 = c2 === 0 ? Number.MIN_VALUE : b[(c2 - 1) / 2 >> 0]
		r2 = c2 === 2 * n ? Number.MAX_VALUE : b[c2 / 2 >> 0] 

		if (l1 > r2) {
			// c1要变小，c2要变大
			j = c1 - 1
		} else if (l2 > r1) {
			// c1要变大，c2要变小
			i = c1 + 1
		} else {
			// 说明 l1 <= r2, l2 <= r1
			break
		}
	}
	// Math.max(l1, l2)即为top k, Math.min(r1, r2)则为top (k+1),
	// 则中位数为 (top k + top (k+1)) / 2
	return k ? Math.max(l1, l2) : (Math.max(l1, l2) + Math.min(r1, r2)) / 2
}

// console.log(findMedian(b, a, 4))